# JS运行机制

#javascript
## 区分进程和线程
- 进程：相当于一个独立的工厂，拥有自己的资源。是cpu分配资源的最小单位
- 线程：相当于工厂的工人，工人之间协作完成任务。是cpu调度的最小单位，线程建立在进程中，一个进程可以有多个线程

## 浏览器是多进程的
- 每打开一个tab页，就相当于增加了一个浏览器的进程，进程内有自己的多线程



## 浏览器包含哪些进程
- 浏览器主进程：只有一个，负责界面显示，与用户交互，网络资源管理
- GPU进程：最多一个，用于3D绘制
- 扩展插件进程：每使用一个扩展就生成一个进程
- 浏览器渲染进程（浏览器内核）：每打开一个tab页，就增加一个进程，负责页面渲染，脚本执行，事件处理



## 浏览器多进程的优势
- 避免单个页面或者插件崩溃了，导致整个浏览器崩溃
- 充分利用CPU多核优势
- 多个进程内存资源消耗也大，用空间换时间



## 浏览器内核
- GUI渲染线程：负责页面的绘制，GUI渲染线程和JS引擎线程互斥，不能同时运行
- JS引擎线程（JS内核）：负责JavaScript脚本的执行，一个浏览器渲染进程中有且只有一个js内核
- 事件触发线程：控制事件循环，事件队列中的事件需等待JS引擎空闲时执行
- 定时触发器线程：setInterval与setTimeout所在的线程，控制定时计数器，计时完毕，进入事件队列中，再等待JS引擎空闲时执行
- 异步http请求线程：执行XMLHttpRequest请求，请求状态变更时触发事件，进入事件队列中，再等待JS引擎空闲时执行

## 浏览器进程和浏览器渲染进程的通信过程
- 浏览器主进程收到用户请求，开始获取页面内容，交给渲染进程
- 渲染线程开始渲染，可能需要GPU进程帮助渲染
- JS引擎线程操作DOM
- 渲染进程将结果返回给主进程
- 主进程将结果绘制出来



## 浏览器内核中线程之间的关系
- GUI渲染线程与JS引擎线程互斥
- JS阻塞页面加载
- WebWorker是浏览器为了应对CPU密集型计算，单开的子线程
- WebWorker是某个渲染进程下的一个线程
- SharedWorker是由单独的进程管理，为多个渲染进程共享使用



## 简单梳理下浏览器的渲染流程
![](http://rbuj999e4.hn-bkt.clouddn.com/dev/1373095523-5a658fc12f1fd.webp)

- 解析html建立DOM树
- 解析css建立样式树
- 将DOM树和样式树合成render树
- 布局render树（Layout/reflow），计算各元素的位置和尺寸
- 绘制render树（paint），绘制页面像素信息
- 将各层信息发送给GPU，GPU将各层合成（composite），GPU呈现到页面上



## load事件与DOMContentLoaded事件的先后
- DOMContentLoaded事件触发时，仅档DOM加载完毕，不包括样式表和图片
- load事件触发时，页面上所有DOM，样式，脚本，图片都加载完毕



## css加载是否会阻塞dom树渲染
- css加载不会阻塞DOM树解析
- 但会阻塞render树渲染，因为render树需要css树信息



## 从Event Loop 谈JS的运行机制
- 事件循环机制
![](http://rbuj999e4.hn-bkt.clouddn.com/dev/1103131299-5a659722e7a98.webp)
- 定时器
当使用setTimeout或setInterval时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。
- macrotask与microtask
  * macrotask: 主代码块，setTimeout，setInterval。在事件队列中，由事件触发线程维护。
  * microtask: promise，process.nextTick，mutationObserver。在微任务队列中，由JS引擎线程维护。
- 运行机制
  * 执行一个宏任务（没有就从事件队列中获取）
  * 执行过程如果遇到微任务，就将它添加到微任务队列中
  * 宏任务执行完毕，立即依次执行微任务队列中的所有微任务
  * 当前宏任务执行完毕，开始检查渲染，GUI线程开始渲染
  * 渲染完毕后，JS线程继续接管，从事件队列中获取下一个宏任务开始执行
![](http://rbuj999e4.hn-bkt.clouddn.com/dev/144425798-5a659724ab503.webp)





